var tool = function () {
    this.primaryKeyColumn = '_pkid';
    this.parentIdColumn = '_parentId';
    this.path = require('path');
    this.fs = require('fs');
};

tool.prototype = {
    /*拼接表名称*/
    createTableName: function (prevNodeName, currNodename) {
        return prevNodeName + '_' + currNodename;
    },
    /*拼接子表和主表的关系列名称*/
    createChildTableForeignColumnName: function (parentTableName) {
        return '_' + parentTableName + 'Id';
    },
    /*替换特殊字符---表名、数据库名*/
    mySqlNameReplace: function (str) {
        return str.replace(/\/|\-/g, '_');
    },
    /*解析数据结果*/
    parseResult: function (result, fn, demoDataObj, count) {
        count = count || 0;
        var _this = this;
        var root = _mapConfig[fn];
        if (!root) return result;
        //20170814  leo 修改创建数据库使用- / 转成 _   查询的时候未做转换
        fn = this.mySqlNameReplace(fn);
        var dataTypeObj = pconst.mapDataType;
        result = (_config.isRealData == true ? result : demoDataObj[fn]) || [];
        var proArr = root.proArr || _mapConfig[root.proArrBy] || [];
        if (proArr.length == 0) {
            return root.type === dataTypeObj.array.name ? {
                data: result, count: count
            } : result[0] || {};
        }
        var sendResult = parse(root, result, fn);
        var returnResult = root.type === dataTypeObj.array.name ? {
            data: sendResult,
            count: count
        } : sendResult;
        return returnResult;

        // 根据DataMapModel  格式化数据
        function parse(node, result, parentTableName, type) {
            // 保存本函数用于递归
            var parse = arguments.callee;

            result = result || [];
            type = type || node.type;
            if (type == dataTypeObj.tree.name) return constructorTree(result, node);
            var fileType = node.fileType || 1;
            var returnResult = [];
            var newTableName, rows, foreignColumn;
            var proArr = node.proArr || _mapConfig[node.proArrBy] || [];

            if (proArr.length == 0) {
                if (type == dataTypeObj.fileArray.name) {
                    for (var i = 0; i < result.length; i++) {
                        var rtrt = result[i];
                        result[i] = rtrt ? '/' + pconst.requestType.pdownload + '/' + psecret.create(rtrt) + '?ft=' + fileType : '';
                    }
                }
                return result;
            }

            // 将Object类型转换成为数组用于循环
            if (!(result instanceof Array)) result = [result];

            // 循环每条返回的信息
            result.reduce(function (returnResult, currRe) {

                // 空值直接过滤
                if (currRe == null) return returnResult;

                //  修改单个实例   循环DataModelMap 中的属性
                var tempObj = proArr.reduce(function (tempObj, currPro) {

                    // 对应项的数据
                    var reValue = _config.isRealData == true ? currRe[currPro.mapName || currPro.name] : currRe[currPro.name];
                    fileType = currPro.fileType || 1;
                    var tempValue;

                    // 根据类型做对应的转换
                    switch (currPro.type) {
                        // 布尔类型
                        case dataTypeObj.boolean.name:
                            tempValue = reValue == true ? true : false;
                            break;
                        // 数字类型
                        case dataTypeObj.number.name:
                            tempValue = Math.toFixed({
                                value: reValue,
                                fixedNum: currPro.fixed,
                                isByInt: currPro.fixedByInt,
                                isToSpecial: currPro.isToSpecial
                            });
                            break;
                        // 字符串类型
                        case dataTypeObj.string.name:
                            tempValue = currPro.isToSpecial !== false ? ptool.emptyStrToHline(reValue) : reValue || '';
                            break;
                        // 日期类型
                        case dataTypeObj.date.name:
                            tempValue = reValue && currPro.format ? reValue.formatDate(currPro.format) :
                                reValue && !currPro.format ? reValue :
                                    currPro.isToSpecial !== false ? ptool.emptyStrToHline(reValue) : '';
                            break;
                        // 文件链接地址
                        case dataTypeObj.fileLink.name:
                            tempValue = reValue ? '/' + pconst.requestType.pdownload + '/' + psecret.create(reValue) + '?ft=' + fileType : '';
                            break;
                        // 类型 Obejct 递归循环
                        case dataTypeObj.object.name:
                            if (_config.isRealData == true) {
                                tempValue = parse(currPro, reValue);
                                break;
                            }
                        // 类型 Array 递归循环
                        case dataTypeObj.array.name:
                            if (_config.isRealData == true) {
                                tempValue = parse(currPro, reValue);
                                break;
                            }
                        // 类型 文件数组 递归循环
                        case dataTypeObj.fileArray.name:
                            if (_config.isRealData == true) {
                                tempValue = parse(currPro, reValue);
                                break;
                            }
                        // 树状类型
                        case dataTypeObj.tree.name:
                            if (_config.isRealData == false) {
                                newTableName = _this.createTableName(parentTableName, currPro.name);
                                rows = demoDataObj[newTableName] || [];
                                foreignColumn = _this.createChildTableForeignColumnName(parentTableName);
                                reValue = rows.filter(function (a) { return a[foreignColumn] === currRe[_this.primaryKeyColumn]; });
                            }
                            tempValue = currPro.type == dataTypeObj.tree.name ? constructorTree(reValue, currPro) :
                                parse(currPro, reValue, newTableName);
                            break;
                    }

                    tempObj[currPro.name] = tempValue;
                    return tempObj;
                }, {})

                //  每个转换完的实例添加到新数组
                returnResult.push(tempObj);
                return returnResult;
            }, returnResult);

            // 根据的传入的类型 返回的对应的结构
            return type == dataTypeObj.object.name ? returnResult[0] || {} : returnResult;
        };

        // 转换为树结构
        function constructorTree(maxArr, currPro) {

            if (!maxArr || maxArr.length == 0) return [];
            //找寻第一级，第一级的父级id在数组内肯定不存在对应的
            var rootArr = [];
            var rootParentId;
            for (var i = 0; i < maxArr.length; i++) {
                rootArr = maxArr.filter(function (a) {
                    return _config.isRealData == true ? a[currPro.mapParentIdTo] == maxArr[i][currPro.mapParentId] :
                        a[_this.primaryKeyColumn] == maxArr[i][_this.parentIdColumn];
                });
                if (rootArr.length == 0) {
                    rootParentId = _config.isRealData == true ? maxArr[i][currPro.mapParentId] : maxArr[i][_this.parentIdColumn];
                    break;
                }
            }
            return find(rootParentId, maxArr, 1);

            //客户端需要的树，要求返回的数据必须是平铺的树
            function find(parentId, arr, level) {
                var returnArr = [];
                for (var j = 0; j < arr.length; j++) {
                    var curr = arr[j];
                    var currParentId = _config.isRealData == true ? curr[currPro.mapParentId] : curr[_this.parentIdColumn];
                    if (currParentId != parentId) continue;

                    var returnObj = parse(currPro, [curr], null, dataTypeObj.object.name);
                    if (!returnObj.id) returnObj.id = _config.isRealData == true ? curr[currPro.mapParentIdTo] : curr[_this.primaryKeyColumn];
                    if (!returnObj.parentId)
                        returnObj.parentId = _config.isRealData == true ? curr[currPro.mapParentId] : curr[_this.parentIdColumn];
                    returnObj.level = level;
                    //arr.splice(j, 1);
                    returnObj.child = arguments.callee(returnObj.id, arr, level + 1);
                    returnArr.push(returnObj);
                    //--j;
                }
                return returnArr;
            };

        };

    }
};

module.exports = new tool();